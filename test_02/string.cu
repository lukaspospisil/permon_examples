
#include "fllopqp.h" /* manipulation with quadratic programming problems (QP) */
#include "fllopqps.h" /* manipulation with solvers (QPS) */
#include "mpi.h" /* get rank of the procesor */

#include <iostream> /* std::cout */
#include <string> /* manipulation with strings */
#include <fstream> /* manipulation with files */
#include <sstream> /* manipulation with string streams */

/* default values */
#define PERMON_EXAMPLES_DEFAULT_N 10
#define PERMON_EXAMPLES_LB_VALUE1 -0.8
#define PERMON_EXAMPLES_LB_VALUE2 -1.5
#define PERMON_EXAMPLES_F_VALUE -0.01

void assemble_problem(int n, Mat &K, Vec &f, Vec &lb, Mat &B){
	PetscErrorCode ierr; /* error handler */

	PetscInt i,j,II,JJ,Istart,Iend; /* iterators */
	PetscReal value;
	PetscInt n_local; /* local size of the f,lb,u */
	
	/* assemble the sparse system matrix */
	ierr = MatCreate(PETSC_COMM_WORLD, &K);CHKERRV(ierr);
	ierr = MatSetSizes(K,PETSC_DECIDE,PETSC_DECIDE,n,n);CHKERRV(ierr);
	ierr = MatSetFromOptions(K);CHKERRV(ierr);
	ierr = MatMPIAIJSetPreallocation(K,5,NULL,5,NULL);CHKERRV(ierr);
	ierr = MatSeqAIJSetPreallocation(K,5,NULL);CHKERRV(ierr);
	ierr = MatGetOwnershipRange(K,&Istart,&Iend);CHKERRV(ierr);
	n_local = Iend - Istart;
	for (II = Istart; II < Iend; II++) { 
		/* non-diagonal entries */
		value = -1.0; i = II/n; j = II - i*n;	
		if (j>0) {JJ = II - 1; ierr = MatSetValues(K,1,&II,1,&JJ,&value,INSERT_VALUES);CHKERRV(ierr);}
		if (j<n-1) {JJ = II + 1; ierr = MatSetValues(K,1,&II,1,&JJ,&value,INSERT_VALUES);CHKERRV(ierr);}
		
		/* diagonal entry */
		value = 2.0; 
		if(j == 0) value = 1.0;
		if(j == n-1) value = 1.0;
		ierr = MatSetValues(K,1,&II,1,&II,&value,INSERT_VALUES);CHKERRV(ierr);
	}
	ierr = MatAssemblyBegin(K,MAT_FINAL_ASSEMBLY);CHKERRV(ierr);
	ierr = MatAssemblyEnd(K,MAT_FINAL_ASSEMBLY);CHKERRV(ierr);
	ierr = MatSetOption(K,MAT_SYMMETRIC,PETSC_TRUE);CHKERRV(ierr);
	ierr = PetscObjectSetName((PetscObject)K,"stiffness matrix");CHKERRV(ierr);

	/* assemble force vector */
	ierr = VecCreate(PETSC_COMM_WORLD, &f);CHKERRV(ierr);
	ierr = VecSetSizes(f,n_local,n);CHKERRV(ierr);
	ierr = VecSetFromOptions(f);CHKERRV(ierr);
	ierr = VecSet(f,PERMON_EXAMPLES_F_VALUE);CHKERRV(ierr);
	ierr = VecAssemblyBegin(f);CHKERRV(ierr);
	ierr = VecAssemblyEnd(f);CHKERRV(ierr);
	ierr = PetscObjectSetName((PetscObject)f,"force vector");CHKERRV(ierr);
	
	/* assemble inequality (bound constraints) vector */
	double a = (PERMON_EXAMPLES_LB_VALUE2-PERMON_EXAMPLES_LB_VALUE1)/0.5; /* parameters of line in right half of lb */
	double b = -0.5*a + PERMON_EXAMPLES_LB_VALUE1;
	ierr = VecDuplicate(f,&lb);CHKERRV(ierr);
	for (II = Istart; II < Iend; II++) { 
		if(II+1 <= 0.5*n){
			value = -0.3;
		} else {
			value = a*((II+1)/double(n+1)) + b;
		}
		ierr = VecSetValue(lb, II, value, INSERT_VALUES);CHKERRV(ierr);
	}	
	ierr = VecAssemblyBegin(lb);CHKERRV(ierr);
	ierr = VecAssemblyEnd(lb);CHKERRV(ierr);
	ierr = PetscObjectSetName((PetscObject)lb,"non-penetration");CHKERRV(ierr);

	/* assemble linear equality conditions */
	ierr = MatCreate(PETSC_COMM_WORLD, &B);CHKERRV(ierr);
	ierr = MatSetSizes(B,PETSC_DECIDE,n_local,2,n);CHKERRV(ierr);
	ierr = MatSetFromOptions(B);CHKERRV(ierr);
	ierr = MatMPIAIJSetPreallocation(B,2,NULL,2,NULL);CHKERRV(ierr);
	ierr = MatSeqAIJSetPreallocation(B,2,NULL);CHKERRV(ierr);

	value = 1.0;
	ierr = MatSetValue(B,0,0,value,INSERT_VALUES);CHKERRV(ierr);
	ierr = MatSetValue(B,1,n-1,value,INSERT_VALUES);CHKERRV(ierr);

	ierr = MatAssemblyBegin(B,MAT_FINAL_ASSEMBLY);CHKERRV(ierr);
	ierr = MatAssemblyEnd(B,MAT_FINAL_ASSEMBLY);CHKERRV(ierr);
	ierr = PetscObjectSetName((PetscObject)B,"dirichlet equality");CHKERRV(ierr);

}

/* inpired by http://public.kitware.com/pipermail/vtkusers/2003-May/017988.html */
void export_solution(Vec &u, Vec &lb, Vec &f, std::string filename){
	PetscErrorCode ierr; /* error handler */
	
	std::ostringstream oss_filename; /* to manipulate with filename */
	std::ofstream myfile; /* to manipulate with file */

	/* get rank and size of MPI comm */
	int size, rank; /* size and rank of communicator */
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);
	MPI_Comm_size(MPI_COMM_WORLD, &size);

	/* master writes main .pvd file */
	if(rank == 0){
		oss_filename << "results/" << filename << ".pvd"; /* compose filename */
		myfile.open(oss_filename.str().c_str()); /* open file */
		oss_filename.str(""); /* clear streaming buffer for next filename */

		/* write header to file */
		myfile << "<?xml version=\"1.0\"?>\n";
		myfile << "<VTKFile type=\"Collection\" version=\"0.1\" byte_order=\"LittleEndian\" compressor=\"vtkZLibDataCompressor\">\n";
		myfile << "<Collection>\n";

		/* writes the collection of files, each file will be generated by one process */
		for(int i=0;i<size;i++){
			myfile << " <DataSet timestep=\"\" group=\"\" part=\"" << i << "\" file=\"" << filename << "_" << i << ".vtp\"/>\n";
		}

		myfile << "</Collection>\n";
		myfile << "</VTKFile>";

		myfile.close();
	}

	/* all processes writes .vtp file with local data */
	oss_filename << "results/" << filename << "_" << rank << ".vtp"; /* compose whole name of file with extension */
	myfile.open(oss_filename.str().c_str()); /* open file */
	oss_filename.str("");

	myfile << "<?xml version=\"1.0\"?>\n";
	myfile << "<VTKFile type=\"Polydata\" version=\"0.1\" byte_order=\"LittleEndian\">\n";
	myfile << "<PolyData>\n";

	/* get size and local ranges of given data */
	int n,Istart,Iend;
	ierr = VecGetSize(u, &n);CHKERRV(ierr);
	ierr = VecGetOwnershipRange(u,&Istart,&Iend);CHKERRV(ierr);
	
	/* get local parts of vectors and store them into the file */
	double *u_arr, *lb_arr, *f_arr;
	ierr = VecGetArray(u,&u_arr);CHKERRV(ierr);
	ierr = VecGetArray(lb,&lb_arr);CHKERRV(ierr);
	ierr = VecGetArray(f,&f_arr);CHKERRV(ierr);

	int n_local = Iend-Istart;
	double h = 1/double(n+1); /* the size of one discretisation element */

	myfile << "<Piece NumberOfPoints=\"" << n_local << "\" NumberOfLines=\"" << n_local-1 << "\">\n";

	/* write points */
	myfile << "<Points>\n";
	myfile << "<DataArray type=\"Float32\" NumberOfComponents=\"3\" format=\"ascii\">\n";
	for(int i=0;i<n_local;i++){
		/* x y z = x u(x) 0 */
		myfile << (Istart+i)*h << " " << u_arr[i] << " 0\n";
	}
	myfile << "</DataArray>\n";
	myfile << "</Points>\n";

	/* write point data - domain_id */
	myfile << "<PointData Scalars=\"domain_id\" Vectors=\"force\">\n";
	myfile << "<DataArray type=\"Float32\" Name=\"domain_id\" format=\"ascii\">\n";
	for(int i=0;i<n_local;i++){
		/* x y z = x u(x) 0 */
		myfile << rank << "\n";
	}
	myfile << "</DataArray>\n";
	/* write point data - force */
	myfile << "<DataArray type=\"Float32\" Name=\"force\" format=\"ascii\" NumberOfComponents=\"3\">\n";
	for(int i=0;i<n_local;i++){
		/* 0 f(i) 0 */
		myfile << "0 " << f_arr[i] << " 0\n";
	}
	myfile << "</DataArray>\n";
	myfile << "</PointData>\n";


	/* write lines */
	myfile << "<Lines>\n";
	myfile << "<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">\n";
	for(int i=0;i<n_local-1;i++){
		/* 0 1 1 2 2 1 .. n-1 n */
		myfile << i << " " << i+1 << "\n";
	}
	myfile << "</DataArray>\n";
	myfile << "<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">\n";
	for(int i=1;i<n_local;i++){
		/* 2 4 6 8 10 */
		myfile << 2*i << "\n";
	}
	myfile << "</DataArray>\n";
	myfile << "</Lines>\n";
	myfile << "</Piece>\n";

	/* write new line with obstacle */
	myfile << "<Piece NumberOfPoints=\"" << n_local << "\" NumberOfLines=\"" << n_local-1 << "\">\n";
	myfile << "<Points>\n";
	myfile << "<DataArray type=\"Float32\" NumberOfComponents=\"3\" format=\"ascii\">\n";
	for(int i=0;i<n_local;i++){
		/* x y z = x u(x) 0 */
		myfile << (Istart+i)*h << " " << lb_arr[i] << " 0\n";
	}
	myfile << "</DataArray>\n";
	myfile << "</Points>\n";
	myfile << "<Lines>\n";
	myfile << "<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">\n";
	for(int i=0;i<n_local-1;i++){
		/* 0 1 1 2 2 1 .. n-1 n */
		myfile << i << " " << i+1 << "\n";
	}
	myfile << "</DataArray>\n";
	myfile << "<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">\n";
	for(int i=1;i<n_local;i++){
		/* 2 4 6 8 10 */
		myfile << 2*i << "\n";
	}
	myfile << "</DataArray>\n";
	myfile << "</Lines>\n";
	myfile << "</Piece>\n";

	ierr = VecRestoreArray(u,&u_arr);CHKERRV(ierr);
	ierr = VecRestoreArray(lb,&lb_arr);CHKERRV(ierr);
	ierr = VecRestoreArray(f,&f_arr);CHKERRV(ierr);
	
	myfile << "</PolyData>\n";
	myfile << "</VTKFile>\n";

	myfile.close(); /* close file */
	
}

int main( int argc, char *argv[] )
{
	/* initialize Petsc */
	FllopInitialize(&argc,&argv,PETSC_NULL);

	/* error handler */
	PetscErrorCode ierr;
  
	/* say hello */
	ierr = PetscPrintf(PETSC_COMM_WORLD,"This is STRING example\n");CHKERRQ(ierr);

	/* prepare variables */
	PetscInt n; /* number of discretisation nodes (size of the problem) */
	Vec u; /* solution vector */
	Mat K; /* stiffness matrix */
	Vec f; /* vector of external forces */
	Vec lb; /* lower bound (rigid obstacle - non-penetration condition) */ 
	Mat B; /* matrix of equality constraints (Dirichlet boundary condition) Bu = 0 */

	/* load console parameters */
	PetscBool set; /* the variable was provided in console parameters or not */
	ierr = PetscOptionsGetInt(NULL,NULL,"-n",&n,&set);CHKERRQ(ierr);
	if(!set) n = PERMON_EXAMPLES_DEFAULT_N;
	
	/* print parameters loaded from console */
	ierr = PetscPrintf(PETSC_COMM_WORLD," n             = %d\n", n);CHKERRQ(ierr);

	/* assemble problem */
	assemble_problem(n, K, f, lb, B);

/*
	TRY( MatView(K, PETSC_VIEWER_STDOUT_WORLD) );
	TRY( VecView(f, PETSC_VIEWER_STDOUT_WORLD) );
	TRY( VecView(lb, PETSC_VIEWER_STDOUT_WORLD) );
	TRY( MatView(B, PETSC_VIEWER_STDOUT_WORLD) );
*/
	
	/* prepare QP problem */
	QP qp;
	ierr = QPCreate(PETSC_COMM_WORLD, &qp);CHKERRQ(ierr);
	ierr = QPSetOperator(qp, K);CHKERRQ(ierr); /* set stiffness matrix */
//	ierr = QPSetOperatorNullSpace(qp,R);CHKERRQ(ierr); /* set null space generator */
	ierr = QPSetRhs(qp, f);CHKERRQ(ierr); /* set righ hand-side vector */
	ierr = QPAddEq(qp,B,NULL);CHKERRQ(ierr); /* add equality constraints from dirichlet, c = 0 */
	ierr = QPSetBox(qp, lb, NULL);CHKERRQ(ierr); /* add lowerbound from contact */
	
	/* print some infos about QP */
	ierr = QPView(qp, PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);

	/* prepare QP solver */
	QPS qps;
	ierr = QPSCreate(PETSC_COMM_WORLD, &qps);CHKERRQ(ierr);
	ierr = QPSSetQP(qps, qp);CHKERRQ(ierr); /* Insert the QP problem into the solver. */
//	ierr = QPSSetTolerances(qps, setting.rtol, setting.atol, setting.dtol, setting.maxit);CHKERRQ(ierr); /* Set QPS options from settings */
//	ierr = QPSMonitorSet(qps,QPSMonitorDefault,NULL,0);CHKERRQ(ierr); /* Set the QPS monitor */
	ierr = QPTFromOptions(qp);CHKERRQ(ierr); /* Perform QP transforms */
	ierr = QPSSetFromOptions(qps);CHKERRQ(ierr); /* Set QPS options from the options database (overriding the defaults). */
	ierr = QPSSetUp(qps); CHKERRQ(ierr); /* Set up QP and QPS. */
	
	/* print some infos about QPS */
	ierr = QPSView(qps, PETSC_VIEWER_STDOUT_WORLD);CHKERRQ(ierr);

	/* solve QP using QPS */
	ierr = QPSSolve(qps);CHKERRQ(ierr);

	/* get solution */
	ierr = QPGetSolutionVector(qp, &u);CHKERRQ(ierr);

	/* export solution into VTK */
	export_solution(u,lb,f,"string_solution");
		
	/* finalize Petsc */
	FllopFinalize();

	return 0;
}


